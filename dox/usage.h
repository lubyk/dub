/**
 * @page dub_usage Dub Usage
 *
 * @section custom_bindings Custom Class, Function, and Attribute Bindings
 *
 * @warning Whether a binding has a semicolon changes its behavior, at least in
 *  		accessor bindings. Should talk about this more, and see where the
 *  		behavior changes.
 *
 * @subsection dub_method_overrides Method Overrides
 *
 * @subsubsection dub_gc Mark this function as factory method.
 *
 * \@dub gc: true
 *
 * Set this value in a method to mark it as a factory method: In other words,
 * it's creating a new object that should be managed by Lua. Only makes sense on
 * functions that return a pointer generated by new.
 *
 * @subsection dub_class_overrides Class Overrides
 *
 * @subsubsection dub_register Change the name of a class
 *
 * @paragraph dub_register_1
 *
 * \@dub register: AlternateName
 *
 * Registers the class using the given AlternateName instead of its actual name.
 * Doesn't change the name of the associated metatable, though.
 *
 * @subsubsection dub_ignore Ignore a member function
 *
 * @paragraph dub_ignore_1
 *
 * \@dub ignore: memberName[, memberName2 ...]
 *
 * Tell Dub to ignore a member; in other words, don't generate any binding
 * information for any functions or member variables with matching names.
 *
 * @subsubsection dub_super Add parent class information
 *
 * @paragraph dub_super_1
 *
 * \@dub super: ParentClass[, ParentClass2]
 *
 * Set parent classes in Dub that Doxygen doesn't know about. Can also be used
 * to add mixins to a class.
 *
 * @subsubsection dub_bind Set binding for a class.
 *
 * @paragraph dub_bind_1
 *
 * \@dub bind: false
 *
 * Setting to false disables binding.
 *
 * @subsubsection dub_cast Set casting for a class.
 *
 * @paragraph dub_cast_1
 *
 * \@dub cast: false
 *
 * Setting to false disables casting.
 *
 * @subsubsection dub_push Mark a function as a "push" function
 *
 * @paragraph dub_push_1
 *
 * \@dub push: functionName -- typically "push"
 *
 * Set the name of the function to push this class onto the Lua stack. The
 * signature of the function should match:
 *
 * @code
 * void pushobject(lua_State* L, void* thisPtr,
 * 					const char * className, bool shouldGC);
 * @endcode
 *
 * Instead of "void *", the <b>thisPtr</b> can be defined as a pointer to the
 * current class. In most cases the pointer here will be the same as
 * <b>this</b>.
 *
 * The <b>className</b> will be passed in as the string that Dub uses
 * to identify the class in question.
 *
 * The boolean shouldGC will be true if Dub believes Lua should garbage-collect
 * the value. In practice this means that the call is being made in the
 * constructor of the class, or a method
 *
 * @subsubsection dub_destructor Set the destructor function for a class.
 *
 * @paragraph dub_destructor_1
 *
 * \@dub destructor: functionName
 *
 * The name of the member function to call to destroy the class. Should call
 * "delete this" if that's needed to destroy the underlying object.
 *
 * @subsubsection dub_destroy_free POD Class Optimization/Destructor Disabling
 *
 * @paragraph dub_destroy_free_1 Dub Command
 * \@dub destroy: 'free'
 *
 * @paragraph dub_destroy_free_1 Inspector Command
 * @code
 * local a = inspector.find("classname");
 * a.dub = { destroy = "free" }
 * @endcode
 *
 * This enables objects to be created with in-place new, preventing an
 * allocation and a copy, and it also completely disables the __gc garbage
 * collection callback for the class.
 *
 * Ideal for POD types that support operators. A vector class Vec2 that supports
 * operator+, for example, would be able to create a single extra Lua USERDATA
 * with an embedded Vec2 result constructed right in the USERDATA.
 *
 * @subsubsection dub_class_init Post-Creation Init
 *
 * @paragraph dub_class_init_1 Dub Command
 * @code
 * \@dub init: 'luaInit'
 * @endcode
 *
 * @paragraph dub_class_init_2 Inspector Command
 * @code
 * local a = inspector.find("classname");
 * a.dub = { init = "luaInit" }
 * @endcode
 *
 * @paragraph dub_class_init_3 Inspector Command
 * Causes Dub to call luaInit function after creating an instance of classname.
 * The luaInit function has the form:
 *
 * @code
 * int luaInit( lua_State * L );
 * @endcode
 *
 * This function can be used to do extra post-construction initialization for a
 * class.
 */
